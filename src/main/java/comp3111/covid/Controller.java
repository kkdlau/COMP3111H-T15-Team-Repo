package comp3111.covid;

import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.beans.value.ChangeListener;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.chart.CategoryAxis;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.NumberAxis;
import javafx.scene.chart.XYChart;
import javafx.scene.control.*;
import javafx.scene.control.Alert.AlertType;
import javafx.scene.control.cell.MapValueFactory;
import javafx.scene.layout.HBox;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
/**
 * Building on the sample skeleton for 'ui.fxml' Controller Class generated by SceneBuilder
 */
public class Controller {

    @FXML
    private TextField textfieldDataset;

    @FXML
    private Tab c3Tab;

    @FXML
    private Tab tabTask12;

    @FXML
    private Tab a3Tab;

    @FXML
    private Tab b3Tab;

    @FXML
    private CheckBox acumulativeCheckButton;

    @FXML
    private ListView<String> countryListView;

    @FXML
    private RadioButton dataCaseButton;

    @FXML
    private RadioButton dataDeathButton;

    @FXML
    private TableView dataTable;

    @FXML
    private RadioButton dataVaccinButton;

    @FXML
    private Label endDataLabel;

    @FXML
    private DatePicker endDatePicker;

    @FXML
    private Label startDateLabel;

    @FXML
    private DatePicker startDatePicker;

    @FXML
    private Button generateButton;

    @FXML
    private TitledPane dataRangeTile;

    @FXML
    private LineChart chart;

    @FXML
    private NumberAxis chartXAxis;

    @FXML
    private CategoryAxis chartYAxis;

    @FXML
    private StackPane stack;

    @FXML
    private VBox rightUI;

    @FXML
    private HBox rootUI;

    @FXML
    private TabPane tabGroup;

    @FXML
    private Label title;

    @FXML
    private Button chartGenerateButton;

    @FXML
    private ListView<String> countryAListView;

    @FXML
    private Slider countryASlider;

    @FXML
    private ListView<String> countryBListView;

    @FXML
    private Slider countryBSlider;

    @FXML
    private LineChart compareChart;

    @FXML
    private LineChart<Float, Float> caseDeathChart;

    @FXML
    private Button caseDeathGenerateButton;

    @FXML
    private Label countryAShiftText;

    @FXML
    private Label countryBShiftText;


    @FXML
    private Label regressionReport;

    ToggleGroup ratioButtonGroups = new ToggleGroup();

    UIDataModel dataInstance = new UIDataModel();

    ObservableList<XYChart.Series<String, Float>> unshifted;

    ObservableList<XYChart.Series<String, Float>> shifted;

    DoubleProperty aShift = new SimpleDoubleProperty();
    DoubleProperty bShift = new SimpleDoubleProperty();


    public void initialize() {
        // default data for data pickers

        startDatePicker.setValue(LocalDate.now());
        endDatePicker.setValue(LocalDate.now());
        stack.getChildren().remove(chart);
        stack.getChildren().remove(dataTable);
        chartXAxis.setAutoRanging(true);
        chartYAxis.setAutoRanging(true);

        this.initializeUIDataModel();
        this.ratioButtonInitialize();

        // Let list view listens to changes of getAvailableCountries().
        // So that when a new dataset is loaded, the list will update also.
        countryListView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);
        this.listViewSubscribe(dataInstance.getAvailableCountries());

        startDatePicker.valueProperty().addListener((ob, oldV, newV) -> dataInstance.start = newV);

        endDatePicker.valueProperty().addListener((ob, oldV, newV) -> dataInstance.end = newV);

        generateButton.setOnAction((e) -> {
            if (dataInstance.acumulativeData.get())
                this.generateChart(dataInstance);
            else
                this.generateTable(dataInstance);
        });

        dataInstance.acumulativeData.addListener((e) -> {
            showTaskUI(!dataInstance.acumulativeData.get());
        });

        tabGroup.getSelectionModel().selectedItemProperty().addListener(onTabChanged);

        acumulativeCheckButton.setSelected(false);
        textfieldDataset.setText(textfieldDataset.getText());

        tabTaskA3Initialize();
    }

    void tabTaskA3Initialize() {
        countryAListView.setItems(dataInstance.getAvailableCountries());
        countryBListView.setItems(dataInstance.getAvailableCountries());

        countryAListView.setOnMouseClicked((e) -> countryASlider.setDisable(false));
        countryBListView.setOnMouseClicked((e) -> countryBSlider.setDisable(false));

        if (countryAListView.getSelectionModel().getSelectedItems().size() == 0) {
            countryASlider.setDisable(true);
        } else {
            countryASlider.setDisable(false);
        }

        if (countryBListView.getSelectionModel().getSelectedItems().size() == 0) {
            countryBSlider.setDisable(true);
        } else {
            countryBSlider.setDisable(false);
        }

        chartGenerateButton.setOnAction((e) -> generateComparsionChart(dataInstance));
        caseDeathGenerateButton.setOnAction((e)-> generateRegressionChart(dataInstance));

        aShift.bindBidirectional(countryASlider.valueProperty());
        bShift.bindBidirectional(countryBSlider.valueProperty());

        aShift.addListener((e) -> {
            double d = aShift.getValue();
            countryAShiftText.setText(String.format("X-axis shift for country A(The situation has been postponed for %d days):", (int) d));
            if (shifted != null)
                shiftingData();
        });

        bShift.addListener((e) -> {
            double d = bShift.getValue();
            countryBShiftText.setText(String.format("X-axis shift for country B(The situation has been postponed for %d days):", (int) d));
            if (shifted != null)
                shiftingData();
        });

        startDatePicker.valueProperty().addListener(((observable, oldValue, newValue) -> {
            int days = (int) ChronoUnit.DAYS.between(newValue, dataInstance.end);
            resetSliderRange(days);
        }));


        endDatePicker.valueProperty().addListener(((observable, oldValue, newValue) -> {
            int days = (int) ChronoUnit.DAYS.between(dataInstance.start, newValue);
            resetSliderRange(days);

        }));
        compareChart.getYAxis().setLabel("Confirmed Cases (per M)");
        compareChart.getXAxis().setLabel("Date");

        caseDeathChart.setCreateSymbols(false);
        caseDeathChart.setAnimated(false);
        caseDeathChart.getXAxis().setLabel("Confirmed Cases (per M)");
        caseDeathChart.getYAxis().setLabel("Confirmed Deaths (per M)");
    }

    private void generateRegressionChart(UIDataModel data) {
        caseDeathChart.getData().clear();

        String iDataset = data.dataPath.get();

        String[] selectedCountries = new String[]{
                countryAListView.getSelectionModel().getSelectedItem(),
                countryBListView.getSelectionModel().getSelectedItem(),
        };

        Object[] ISO = dataInstance.getISOList(FXCollections.observableList(Arrays.asList(selectedCountries)));
        String[] ISOStrings = Arrays.copyOf(ISO, ISO.length, String[].class);

        if (ISOStrings.length == 0) {
            Alert error = new Alert(AlertType.ERROR);
            error.setContentText("Please select at least one country");
            error.show();
            return;
        }

        ObservableList<XYChart.Series<Float, Float>> d = DataAnalysis.casesAndDeathsData(iDataset, ISOStrings[0],ISOStrings[1]);
        d.get(0).setName(selectedCountries[0]);
        d.get(1).setName(selectedCountries[1]);

        LinearRegression regressionA = LinearRegression.fromSeries(d.get(0));

        XYChart.Series rgA = regressionA.generateMockData();
        rgA.setName(String.format("Regression - %s", selectedCountries[0]));
        LinearRegression regressionB = LinearRegression.fromSeries(d.get(1));
        System.out.println(regressionB.toString());
        XYChart.Series rgB = regressionB.generateMockData();
        rgB.setName(String.format("Regression - %s", selectedCountries[1]));

        d.add(rgA);
        d.add(rgB);
        generateRegressionReport(regressionA, regressionB, selectedCountries[0], selectedCountries[1]);

        caseDeathChart.setData(d);
    }

    void generateRegressionReport(LinearRegression rgA, LinearRegression rgB, String countryA, String countryB) {
        String output = "Regression report:\n\n";
        output += String.format("Relationship of %s - %s\n", countryA, rgA.toString());
        output += String.format("Relationship of %s - %s\n\n", countryB, rgB.toString());

        LinearRegression better = rgA.slope() > rgB.slope()? rgB: rgA;
        String betterCounrty = rgA.slope() > rgB.slope()? countryB: countryA;
        LinearRegression worse = rgA.slope() > rgB.slope()? rgA: rgB;

        output += String.format("Conclusion: %s has better health care since it has lower slope (%.3f < %.3f).", betterCounrty, better.slope(), worse.slope());
        regressionReport.setText(output);
    }

    /**
     * Reconfigure the range of slider.
     *
     * @param days the maximum days that a slider can have.
     */
    private void resetSliderRange(int days) {
        countryASlider.setValue(0);
        countryBSlider.setValue(0);

        countryASlider.setMax(days);
        countryBSlider.setMax(days);
    }

    ChangeListener<Tab> onTabChanged = (ov, disSelected, selected) -> {
        if (disSelected == tabTask12) {
            rootUI.getChildren().remove(rightUI);
        } else if (disSelected == a3Tab) {
            rootUI.getChildren().remove(rightUI);
            rightUI.getChildren().add(stack);
        } else if (disSelected == b3Tab) {

        } else if (disSelected == c3Tab) {

        }

        if (selected == tabTask12) {
            rootUI.getChildren().add(rightUI);
        } else if (selected == a3Tab) {
            rootUI.getChildren().add(rightUI); // reuse the right UI
            rightUI.getChildren().remove(stack); // but don't keep the stack
            title.setText("COVID-19 Confirmed Cases Report"); // update title
            showPickPeriodUI();
        } else if (selected == b3Tab) {

        } else if (selected == c3Tab) {

        }
    };

    public void ratioButtonInitialize() {
        dataCaseButton.setToggleGroup(ratioButtonGroups);
        dataDeathButton.setToggleGroup(ratioButtonGroups);
        dataVaccinButton.setToggleGroup(ratioButtonGroups);

        ratioButtonGroups.selectedToggleProperty().addListener((ob, oldVal, newVal) -> {
            dataInstance.focusedData = buttonDataMapping((RadioButton) ratioButtonGroups.getSelectedToggle());
        });
    }

    public void listViewSubscribe(ObservableList src) {
        countryListView.setItems(src);
    }

    public void initializeUIDataModel() {
        dataInstance.dataPath = textfieldDataset.textProperty();
        dataInstance.dataPath.addListener((e) -> {
            UIDataModelUtils.setAvailableCountries(dataInstance);
        });

        dataInstance.focusedData = this.getFocusedData();
        dataInstance.start = startDatePicker.getValue();
        dataInstance.end = endDatePicker.getValue();
        dataInstance.acumulativeData = acumulativeCheckButton.selectedProperty();
    }

    InterestedData getFocusedData() {
        if (dataCaseButton.isSelected())
            return buttonDataMapping(dataCaseButton);
        else if (dataDeathButton.isSelected())
            return buttonDataMapping(dataDeathButton);
        else
            return buttonDataMapping(dataVaccinButton);
    }

    InterestedData buttonDataMapping(RadioButton btn) {
        if (dataCaseButton == btn)
            return InterestedData.ConfirmedCases;
        else if (dataDeathButton == btn)
            return InterestedData.ConfirmedDeaths;
        else
            return InterestedData.RateOfVaccination;
    }

    void generateTable(final UIDataModel data) {
        System.out.println(dataInstance.focusedData);
        String col1Title = "", col2Title = "";
        switch (getFocusedData()) {
            case ConfirmedCases:
                col1Title = "Total Cases";
                col2Title = "Total Cases (per 1M)";
                break;
            case ConfirmedDeaths:
                col1Title = "Total Deaths";
                col2Title = "Total Deaths (per 1M)";
                break;
            case RateOfVaccination:
                col1Title = "Fully Vaccinated";
                col2Title = "Rate of Vaccination";
                break;
        }

        dataTable.getItems().clear();
        dataTable.getColumns().clear();
        TableColumn<Map, String> country = new TableColumn("Country");
        TableColumn<Map, String> col1 = new TableColumn(col1Title);
        TableColumn<Map, String> col2 = new TableColumn(col2Title);
        dataTable.getColumns().addAll(country, col1, col2);
        String[] validDate = CheckInput.checkValidDate(dataInstance.start, dataInstance.dataPath.get());
        System.out.println(validDate[0]);

        // todo: make it support any interest of data
        ObservableList<String> selectedCountries = countryListView.getSelectionModel().getSelectedItems();
        Object[] ISO = dataInstance.getISOList(selectedCountries);
        String[] ISOStrings = Arrays.copyOf(ISO, ISO.length, String[].class);

        if (ISOStrings.length == 0) {
            Alert error = new Alert(AlertType.ERROR);
            error.setContentText("Please select at least one country");
            error.show();
            return;
        }

        ObservableList tableData = VaccinationRate.generateVacTable(dataInstance.dataPath.get(), Arrays.asList(ISOStrings),
                validDate[1], getFocusedData());
        country.setCellValueFactory(new MapValueFactory<>("country"));
        col1.setCellValueFactory(new MapValueFactory<>("col1data"));
        col2.setCellValueFactory(new MapValueFactory<>("col2data"));

        dataTable.getItems().addAll(tableData);
    }

    void shiftingData() {
        int shiftA = (int) aShift.get();
        int shiftB = (int) bShift.get();

        XYChart.Series<String, Float> countryAData = unshifted.get(0);
        XYChart.Series<String, Float> countryBData = unshifted.get(1);

        for (int i = 0; i < countryAData.getData().size(); i++) {
            XYChart.Series<String, Float> shiftedA = shifted.get(0);
            XYChart.Data<String, Float> d = unshifted.get(0).getData().get(i);

            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
            LocalDate date = LocalDate.parse(d.getXValue(), formatter).plusDays(shiftA);
            shiftedA.getData().set(i, new XYChart.Data<String, Float>(date.toString(), d.getYValue()));
        }

        for (int i = 0; i < countryBData.getData().size(); i++) {
            XYChart.Series<String, Float> shiftedB = shifted.get(1);
            XYChart.Data<String, Float> d = unshifted.get(1).getData().get(i);

            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
            LocalDate date = LocalDate.parse(d.getXValue(), formatter).plusDays(shiftB);
            shiftedB.getData().set(i, new XYChart.Data<String, Float>(date.toString(), d.getYValue()));
        }

    }

    void generateComparsionChart(final UIDataModel data) {
        compareChart.getData().clear();

        String iDataset = data.dataPath.get();

        String[] selectedCountries = new String[]{
                countryAListView.getSelectionModel().getSelectedItem(),
                countryBListView.getSelectionModel().getSelectedItem(),
        };

        Object[] ISO = dataInstance.getISOList(FXCollections.observableList(Arrays.asList(selectedCountries)));
        String[] ISOStrings = Arrays.copyOf(ISO, ISO.length, String[].class);

        if (ISOStrings.length == 0) {
            Alert error = new Alert(AlertType.ERROR);
            error.setContentText("Please select at least one country");
            error.show();
            return;
        }

        LocalDate iStartDate = data.start, iEndDate = data.end;
        List<String> checkPeriodInput = CheckInput.checkValidPeriod(iStartDate, iEndDate, iDataset);
        if (checkPeriodInput.size() == 1) {
            Alert error = new Alert(AlertType.ERROR);
            error.setContentText("Please select a valid date period");
            error.show();
            return;
        }
        if (!checkPeriodInput.get(checkPeriodInput.size() - 1).isEmpty()) {
            Alert info = new Alert(AlertType.INFORMATION);
            info.setContentText(checkPeriodInput.get(checkPeriodInput.size() - 1));
//            info.show();
        }

        checkPeriodInput.remove(checkPeriodInput.size() - 1);
        if (checkPeriodInput.get(0).equals(checkPeriodInput.get(1))) chart.setCreateSymbols(true);
        else compareChart.setCreateSymbols(false);
        unshifted = VaccinationRate.generateVacChart(iDataset, Arrays.asList(ISOStrings), checkPeriodInput, getFocusedData());
        shifted = FXCollections.observableArrayList(unshifted);

        shiftingData();
        compareChart.setData(shifted);
    }

    void generateChart(final UIDataModel data) {
        chart.getData().clear();

        String iDataset = data.dataPath.get();

        ObservableList<String> selectedCountries = countryListView.getSelectionModel().getSelectedItems();
        Object[] ISO = dataInstance.getISOList(selectedCountries);
        String[] ISOStrings = Arrays.copyOf(ISO, ISO.length, String[].class);

        if (ISOStrings.length == 0) {
            Alert error = new Alert(AlertType.ERROR);
            error.setContentText("Please select at least one country");
            error.show();
            return;
        }

        LocalDate iStartDate = data.start, iEndDate = data.end;
        List<String> checkPeriodInput = CheckInput.checkValidPeriod(iStartDate, iEndDate, iDataset);
        if (checkPeriodInput.size() == 1) {
            Alert error = new Alert(AlertType.ERROR);
            error.setContentText("Please select a valid date period");
            error.show();
            return;
        }
        if (!checkPeriodInput.get(checkPeriodInput.size() - 1).isEmpty()) {
            Alert info = new Alert(AlertType.INFORMATION);
            info.setContentText(checkPeriodInput.get(checkPeriodInput.size() - 1));
            info.show();
        }
        checkPeriodInput.remove(checkPeriodInput.size() - 1);
        if (checkPeriodInput.get(0).equals(checkPeriodInput.get(1))) chart.setCreateSymbols(true);
        else chart.setCreateSymbols(false);
        ObservableList<XYChart.Series<String, Float>> allData = VaccinationRate.generateVacChart(iDataset, Arrays.asList(ISOStrings), checkPeriodInput, getFocusedData());
        chart.setData(allData);
    }

    void showTaskUI(Boolean isTask1) {
        if (isTask1) {
            title.setText("Data Table");
            showPickDateUI();
            stack.getChildren().remove(chart);
            stack.getChildren().add(dataTable);
        } else {
            switch (dataInstance.focusedData) {
                case ConfirmedCases:
                    title.setText("Cumulative Confirmed COVID-19 Cases (per 1M)");
                    break;
                case ConfirmedDeaths:
                    title.setText("Cumulative Confirmed COVID-19 Deaths (per 1M)");
                    break;
                case RateOfVaccination:
                    title.setText("Cumulative Rate of Vaccination against COVID-19");
                    break;
            }
            showPickPeriodUI();
            stack.getChildren().remove(dataTable);
            stack.getChildren().add(chart);
        }
    }

    void showPickDateUI() {
        dataRangeTile.setText("Date");
        startDateLabel.setText("Date: ");
        endDataLabel.setVisible(false);
        endDatePicker.setVisible(false);
    }

    void showPickPeriodUI() {
        dataRangeTile.setText("Date Range");
        startDateLabel.setText("Start date: ");
        endDataLabel.setVisible(true);
        endDatePicker.setVisible(true);
    }
}

